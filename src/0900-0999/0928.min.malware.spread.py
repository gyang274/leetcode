from typing import List
from collections import Counter, defaultdict

class DSU:
  def __init__(self):
    # representer
    self.reps = {}
    self.size = {}
  def add(self, x):
    self.reps[x] = x
    self.size[x] = 1
  def find(self, x):
    while not x == self.reps[x]:
      x = self.reps[x]
    return x
  def union(self, x, y):
    hX = self.find(x)
    hY = self.find(y)
    if not hX == hY:
      h = min(hX, hY)
      if h == hX:
        self.reps[hY] = h
        self.size[hX] += self.size[hY]
        self.size.pop(hY)
      else:
        self.reps[hX] = h
        self.size[hY] += self.size[hX]
        self.size.pop(hX)

class Solution:
  def minMalwareSpread(self, graph: List[List[int]], initial: List[int]) -> int:
    n = len(graph)
    # connected components with no malware
    dsu = DSU()
    for i in range(n):
      dsu.add(i)
    healths = set(range(n)) - set(initial)
    for u in healths:
      for v in healths:
        if graph[u][v]:
          dsu.union(u, v)
    # dM2H: component id connected by each malware
    # dH2M: malware id connected by each component
    dM2H, dH2M = defaultdict(set), defaultdict(set)
    for u in initial:
      for v in healths:
        if graph[u][v] == 1:
          dM2H[u].add(dsu.find(v))
          dH2M[dsu.find(v)].add(u)
    # component of health nodes is immuned if it is 
    # connected to only one malware and its removed
    r, s = None, -1
    for u in initial:
      m = 0
      for v in dM2H[u]:
        if len(dH2M[v]) == 1:
          m += dsu.size[v]
      if m > s or (m == s and u < r):
        r, s = u, m
    return r

if __name__ == '__main__':
  solver = Solution()
  cases = [
    ([[1,1,0],[1,1,0],[0,0,1]], [0,1]),
    ([[1,1,0],[1,1,1],[0,1,1]], [0,1]),
    ([[1,1,0],[1,1,0],[0,0,1]], [0,2]),
    ([[1,1,0],[1,1,0],[0,0,1]], [0,1,2]),
    ([[1,1,0,0],[1,1,1,0],[0,1,1,1],[0,0,1,1]], [0,1]),
  ]
  rslts = [solver.minMalwareSpread(graph, initial) for graph, initial in cases]
  for cs, rs in zip(cases, rslts):
    print(f"case: {cs} | solution: {rs}")
