from typing import List
from collections import Counter

class DSU:
  def __init__(self):
    # representer
    self.reps = {}
    self.size = {}
  def add(self, x):
    self.reps[x] = x
    self.size[x] = 1
  def find(self, x):
    while not x == self.reps[x]:
      x = self.reps[x]
    return x
  def union(self, x, y):
    hX = self.find(x)
    hY = self.find(y)
    if not hX == hY:
      h = min(hX, hY)
      if h == hX:
        self.reps[hY] = h
        self.size[hX] += self.size[hY]
        self.size.pop(hY)
      else:
        self.reps[hX] = h
        self.size[hY] += self.size[hX]
        self.size.pop(hX)

class Solution:
  def minMalwareSpread(self, graph: List[List[int]], initial: List[int]) -> int:
    n = len(graph)
    # connected components
    dsu = DSU()
    for j in range(n):
      dsu.add(j)
      for i in range(j):
        if graph[i][j]:
          dsu.union(i, j)
    # component id of each one
    d = Counter(map(dsu.find, initial))
    # remove with reduced size
    r, s = None, -1
    for i in initial:
      h = dsu.find(i)
      # reduced size by remove i
      m = 0 if d[h] > 1 else dsu.size[h]
      if m > s or (m == s and i < r):
        r, s = i, m
    return r

if __name__ == '__main__':
  solver = Solution()
  cases = [
    ([[1,1,0],[1,1,0],[0,0,1]], [0,1]),
    ([[1,1,0],[1,1,0],[0,0,1]], [0,2]),
    ([[1,1,0],[1,1,0],[0,0,1]], [0,1,2]),
  ]
  rslts = [solver.minMalwareSpread(graph, initial) for graph, initial in cases]
  for cs, rs in zip(cases, rslts):
    print(f"case: {cs} | solution: {rs}")
